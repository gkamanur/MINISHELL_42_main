# **************************************************************************** #
#                                                                              #
#                                                         :::      ::::::::    #
#    build                                              :+:      :+:    :+:    #
#                                                     +:+ +:+         +:+      #
#    By: gkamanur <gkamanur@student.42.fr>          +#+  +:+       +#+         #
#                                                 +#+#+#+#+#+   +#+            #
#    Created: 2025/07/29 13:35:29 by robello           #+#    #+#              #
#    Updated: 2025/08/27 15:45:15 by gkamanur         ###   ########.fr        #
#                                                                              #
# **************************************************************************** #


1. Foundation & Interactive Shell Loop
	Set up your interactive main loop:
	Use readline() for input, display a prompt (e.g., minishell$ ).
	Add non-empty commands to history with add_history().
	Handle exit on Ctrl-D (NULL from readline()).
	Clean memory for your shell, not forgetting the readline pointer.
	Implement robust signal handling IN THE SHELL:
	SIGINT (Ctrl-C): prints newline, redisplays prompt, discards current input
	SIGQUIT (Ctrl-$$: does nothing at prompt
	Use at most one global variable for signals

Test: Shell must always display the prompt, handle input, exit gracefully (Ctrl-D), and respond to signals exactly as Bash.

2. Simple Line Parsing and Executor Scaffold
	Write a simple tokenizer that splits the line into commands (by |) and arguments (by spaces).
	For now, ignore complex quoting/redirection—focus on:
	Splitting a line (e.g., ls -l | grep foo | wc -l) into linked lists or arrays of command/args.
	Wire your pipex execution model to run these parsed tokens as external commands (no builtins yet, no redirs), using fork/execve.
	Test: Run simple pipelines (ls | cat, ls -l | wc -l) interactively.

3. Core Redirections
	Add parsing for <, >, >>, and << as tokens for each command.
	Implement the logic to open the appropriate file descriptors before running each child process.
	Test: Try cat < myfile, echo test > log, echo X >> log.

4. Parser/Tokenizer with Complete Quoting Support
	Implement full, stateful parsing for:
	Quotes: single ('...'), double ("...")
	Escaped characters (if the subject or readline returns them)
	Syntax errors: handle unclosed quotes, ambiguous/malformed input
	Test: Try edge cases—quoted spaces, nested/close quotes, malformed lines.

5. Variable Expansion ($VAR, $?)
	Implement a parser pass that expands environment variables (excluding inside single quotes).
	Handle expansion rules for double quotes, unquoted args, and $?.
	Test: echo "$HOME", echo '$HOME', echo $?, assignments, undefined vars.

6. Built-in Commands (with environment management)
	Write the logic for each mandated builtin:
	cd, echo -n, pwd, env, export, unset, exit
	Make sure builtins mutate and use your own environment (not the system’s), and that only these builtins alter it.
	Test: All builtins independently and chained; variable exports; effect on subsequent commands.

7. Environment Handling
	Implement a modifiable environment (copy envp on startup, malloc’ing new entries as needed).
	All env changes (by builtins) are to your in-memory copy.
	Test: export, unset, effect on env, effect on external commands.

8. Status Codes and Clean Process/Signal Management
	Ensure every command, builtin, syntax error, or failed fork/exec sets $? as bash does.
	Foreground signals (Ctrl-C/Ctrl-$$ are handled by children as in bash.

9. Complete Error Handling and Memory Management
	Test every error case (file open fail, permission denied, syntax errors). Ensure:
	Leaks and double-frees are eliminated (valgrind clean for your code).
	The Norm is respected everywhere.

10. Integration Testing & Finishing Touches
	Try complex pipelines, redirections, and builtins in every combination.
	Test signal edge-cases and memory leaks intensively.
	Ensure Makefile is correct, no unnecessary relink, all rules present.
	Validate you use only allowed functions.
	If You Want to Attempt Bonus:
	Only start once everything above is perfect and stress-tested!
	Add parsing for &&, ||, and (), then implement short-circuiting logic and priorities.
	Implement basic * wildcard/globbing in argument expansion.




grep "minish" *


